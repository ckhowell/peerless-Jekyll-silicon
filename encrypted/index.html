<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"88b2cd6cbe4c2f7d3a6bb97ab4445b3a4368b6785a51d43b5251c01869b203f547cc32afde61c0b8fd865c27ea87753f8da16aa9724999df5bdc8edbbf7ba67b79026602d8b66cb0d35b7b42aa84eeafbb3328fd8fabd355c7b12f81b860d26a563bae2580f429702a08b5aa81a5c20fff37920e17ff9ccf018fef197e416ea9b9951e1e56cf89ddf962aa886d3ca7b17eb4d526f954331782f4497b1fa6e7fcf6dcf77d109b070e372f3be709fc39e202568e288a78b35ad3f5b46228df8469bf1854626b50644d4dc8514362dc50b9c93504b3d8e5de723f8fc106de8319e0f85f2eb0059cebaeedc208449b74e5dee6990961793d49af818ee4083e60a1d5ac895701d53a772aaa813b4c3e3b07d440cf06b3da73726db9e1e4ebd570dd2ee6f9c75086d85539edd59173d1576befdfeadc45e8a4736671254b14c6f40cf5f1571f2ad1b7e3a681927290daa216ba993b256735e4012fc71da4906a13fc752e2ad70d0da8e938c8ea81d4b3f061a7af63bc17f6cec4766a3b73ae27a5d6b74d7ebc25d8122e019adc37ce0fa4bd146e0b62dfc6a770203a1e5144b67f852a1975c03023bb50e71b09199c43a34095c9d4a48b84326b700fe6fc5d9f71f5ad069374588fb3a8d321ec761c5cf3e0fc28e5b2168dc19ad070c74f444c59c1e7a5e14997e9994fe58fb06a0d41481d005968ca71147c30ab48e6232318d356e29078b90bfaed9ae5799646b358854f0f9dc1b345a67ed87a58195c8cd179692da8366065a6b42ad07bb1761adcb0d89a38309e75f12602e6e822b260c59571c8ce2acafde1ea979479e7c40aab8618140de56d8aa81566d1d4f5e448284042aa11a6f4d3b9f831f9ec814629d279c725330bcd0e53d6b5c4765bd4998fe093aa00dc82d5dcfc9c06f1cfac11115af69f800dd55b6e4bf9e167b3329776003e1c13a9d2bbf1c0fb5dc8fb0239a4402f7be76ad50c5506a0d23ea5e94d67dfccf043bc76b5cfb0be76570d069355e50fe618d783f14ea8d2b13276a1768e5092f6c8c6498383df21ccf733cbfce44faf16a7fd5dd8610eae5b76d158f662039c3a0baa7afce83981e19e00e3956b52b98ebc09a9abb42bf0e8b7dc98f88cbc5352c5826ae7d1c9b67f6b8ee49d980839e9f743b0318281f6323ffb19c83528b83b283fccbf4c40f30875483929d380247748e2d3c9441a90be5bf27b7b4e2afb20c39178ca2eb7b15baea2a7059e261b09f42dbae9471674cae3a75aeaca1ffe239a0b90d10de632c317ebf903af0efe6406430cada18bfd1e4215d1f2db90581826ac38375a7bfe8cd33e59790b2199fabfcfbbabc4c066a2e4e24c15923af2bb4d86b0ac0267b8a3d2ab1335ec085b8b7bfaf99b12d860d62061d083ce5968c4698460a6444c57858928d588346d8bbd4e9a790170fbd8fe6bf4a0fe6888c0697db5b4ac8d23eef9f521bb80e7734d7c9138eeaebc800e667e465942d182709b4208c5a9af51f35f9b0d2cf3520ada24b15a8daa0b30a30f3462661614f08f1789140e96cc4d24f562e97f2531fe14e47f4cfbeb3fcc874d90cf91179073d9f895d0d2acc96c201a6228bbc6cd4992476c27b3918afe2e013c10dc9ffb5eb223984926a6ee71e8e605eb4bf8074cf2a70b1d6ae49e1128f51a81cbbd61b24834fca4d7657b90252daf1dd0684b975e3f1c7af67e926b35da4cd5b417919779b400c338a3209cb71595df581189173a523474061ab83cc4f17da805f10d70d81815bdee80bb6cc7ad9869c016c9eaf3dba57231b363a748f131b86a2ba3c4af11ff781af8e0d36b2943603fd9569af8dd8d11114bc311586df6e3fc27c7905c9e7ef0d363038b738d1fb148a281e25c9abd03bd0693daeffc16b1bcced0aaa2f2630d189eac194f7e5874755f93b80fce1ee3abd99a954be4ef63131b2e35442025340940037ff1dafed20c580d0788575a39dfb6216ebe11e19c213a61e7a7fbd9d79315ac38526fd107a38540edba60b2947b0ceca693088005a22baa8275c8595466eb61b03de0762374c7162b628b3245fb62e68d7f303107fa5af17e4b3b986262e0414226c6e81820fbdb9ed18e828da5a2160d81a9789a6b0bdd853907194c6dc240dc3df19185460efe665796948699e9609bf46b1a00c818529831af74d5d2febc1a39e8957223ed304645e491bb7d8ee06f269468704959cd2a2eeae478dcf819b18fd61c814630ad3713c92c2686ce7e8efeec1b4aa73b126a1b18a4f14a7a5796084ca66dad28bdf23c28905ec530c42a2daf2e695a72b9544f7dd5dcd2198d0a918f48412ed328ec226f5d3fd928ee6e5b2140a79a5aa44b1a0a8a5281aea922bcf20cc7a80ea53dcb5e248789b69d6a0c21d1b421153d3238db289aba1f66cf828fdf476e67d271cfb9fd53d51967eb75096fb8421f10de5cb428e01571277b7fce803368fa17f8ef09b2fabcdc91a7d1b9057f59f18093dfcbdf2b23e26fb64f3727b9cbb09a10472a318ff30c46b063caed5d2a4f716121cd67db776a53565fe4d4508206808bbad126317c4df90a1fd4cf9daeeb2fab9798241a5952b8cb1a6385f05c842155da885be00a9092b88e0c57164aa2a0ec456130dff6f93adea2750f497a2f6e06de6c9e56a161aaa02299a5c2188c192cca112909dd4f36451e0759d911a542a5ffd120d1e750dbd518ae592471e9242aed95a736cd4765ad045011a1422862ec817dac2a4494c0e4a8f8dce2a27a3edffaf7128e233cad1172b88c3c03cbd70445f3506d485fb9494da27624bd71c1b4c17b4ea27275f275b6010ac11e67e4461abf17cb56a4aa418501e8b24f64805e8ff964ad415dc9a0c0251282d243037b513f88ab0f7f0eae64b6a9e8dea66557b16f2017672a6337203c0e61298fe72cebe653550c7afd8d1e54dd4116e70c32f1faf59614b4445a66661b8bf6182cfa4de105badf19e3296bec7e6295fc08717168b595079a37222c19ae6ab0b23e11fb9406b5d795affe07da79b262cc06b04a0cc22315ed23d875ee1dc8cb581b922bf9e97a7e3f5bbaf697823e9f5050822fdee6b2cf331670a49de7d9dd48025eedc0f929a7aec6fa8d9a14d2e18211516bde1335336fd796ec5494b666d18193650ebc2670ae1f564b3ca6bca1b96b824f14512705556e7134d045254c699bbec03ffc6d4f2f51a91999f0b2df4e69d15179ccbda956b73bc57b6948cd84aa8d921db2f2094d319f48c3f3791f050aff827852523c2835aa4cfe465742952bf02e4675d2bad3edbe4f0205e36e2e6df5fab6d02662e83baf9e3fb882231162567e77e4a2083be8dd858f84cf22c873ccb8939e176b285bdfba87aac07ca05404a863a7672d351249d3022c44f8164952b15d4cf99f3224bdd5913c04cb340a0409e27dee9d64322c65e7e36e17a5edb1d5eb0ccc4b21ec7c47b6eac33147a12180db84212c2add1b337db55ec52ef47eaa4064299c5b36e708c1742aeff6ca4efa90a668dface084b3d320fdec7aec40fcfd0c8bdbf634e66f04afc936514b03de6f2eca83b035d301ffc464749db3fa3b218cb20321fa85011c31b5cd3f59f1221bd184be5e3c46e10b2eb3dc202a0fc598cd8ed45433d4f745b646181301847a3b9e9e32f8bf9d026fdb43e6c41a7e7575241cc1ac92d95efe82b7cc91356ea5ec83605bde3236c0641e37ac90763c378f2b080d8b8bda8d26e336a1aa9e292e8298508c7fa76f010d2330f312a28a8b5e5f3d735e1c514cffcfebaa6cb85674e442dc766c57023ac80b56417f0ae279ea864e6343cf0657db60fadf0b26ddcd32926ed296001d0ebf2acbb3805b1c1e777884defff68d7899a772a3bcda78f82452fa3b5dbc0ff1578628eb1e9e449dce8cef898832fe63e738711913229e4365f3635efec9af5e28d12387d504d00ea35dc15bd3278c188cd9174e31eec06800dafda47b6467a310652ad50076c9b65f16153f64ef02b97d95bf1f64037ec17f1b9a04280dd791aef46a614a0dfea397d4c2ecb1a07930f3c48c598c712cddfd8c0117961787fa2b7de838bdc963f83f71cf7a813040840a11d8a3ec32e64c045a331b58fb20d6983043609fd8ddd08306f0c0aa50903336d094a76c29ff836ad1511706482a5b41fb23d401243d72cbc4d3881d63de6cb40e573826e45963df24956f84787ec01be46ee4f90791cc335676ef218580ab9bc0d505fd061c44b7015d320bef063848eb2069157337baf47883a82c80bedf063063b67ae8541c90c83b57106cca01f77fd6bb303a7490898786d82b2ef4680af4c0dda221ef33e0d90a4daa06203a1a895ceeaf95675199719ba684eb33ecda95c1e2db792b9ff92fe5b9e9c9964272a3f1fbf6c7c69245532a2b675732b81f06fafa8d6e5bacb8f9856ce6c73800d5fbb4e64e557d9175467c9894fdc16b01ab67d4b6c01f4f9acfcc66dbe34a4d9c3e12993b027ad3a6392f2e316e254313f99ca8e86eff130df2c827dcfb979fd2694fa70b969a265c130cb13c7d3493849bdf22702a0787a7886b38a0932a0c521decd5f2367b5cda29a21622ce08a6906d3c799aa7c870727097b84ce289690b82896a0766d2cb76fe253049bac3ca0c7f072d33786b46e96fcd3efa56d7a230b2e4120d5d784c9c2b9ebfbebc0fb17dd913fb2c32e79e54e0295fa6bf2c583703dfbf6dcfd8734fef112ab721e0bea0a8e760e8e48c074fee29fd6402aab48d958f13fdcf4ea55cc36363d82336140565dcd53c9b8f51721cb2507195dd474bd8a57d641ca5c1dd2d160c993ca6d496c97d762ff3c710f8cba1972a9c9bfab730252e72601e927108ea0e6a1485912eb9caee0e56b25ba230b161f6625e7ece5c06697c3a1ebc23674260d41ca86155489689bdc1d8fb86ae9e2ad89403b110343fdc73086f06441852d0345292aafde0e65edb60658fa8b586c5a07afe46c910f5fe022f5ac06915f44b75e947b539356ce4c178d761df02b23f140436d56d7260d364f918cee6cc055d5b1c33841b1ec3d651f81a58c8156b82c1ca9a606699eb1c1e8a689e9ba03ee04f25541d3cea9f76d9575a1374671d2f0d2dc91c07211043c55d33cffab840cd0028697fff94522951b9128e0eb52805e7713931422ef1ef0377e20aa1781f71e711e32722697f0abb71ef32cf91eb24138df2414dbcce1b6ecd2a25739ce6738b87670050225e8b4e0343f7199f680a88dde0d405d880bf16bb8cfcf85692c8a8dcd3a5473bd474582e2dca31c1dff5ea3f0f35ae106a2e25f3b97c21c7722aed60785342bb4c08beaca6dee22bbc0ac4d853b42e6374536a675937d31e63a78a740e2466366f22c825fbd6a68b752a674ca055e7e5403ad7da2fff5c1d22d8a1e6a4b8b9ae0451291e2937ad98e624fdb08b8ae174b2b52a7065958df4c568c9f6dda8f16adad0265206ccc98d03bfa7ea0814393c796a422f69cc70c0af8e3f1695459229d3cf7693507e4c3aa1821e37977bdf767b4dbe7ce9df325f8be7bb97fe28b8cf7a5f997448ad35059f6b7bcf8da7b095009aec2539d66e36d849831d6372fbf7c16eb596f8d9144d0153db1e8738d52ca1da4a741f0851775e1b26d5e3b16cd51c8d27038b7663fa6f47cc33b06ff8b7e71fcb498263508bf9e055fb3eeb2ebc00c0bcbf2c0c91a0a6385d2686fc8e61cdc74018f94e70c747bbc3c3fa1ccc4695327cb73a335ced5a433b720b832c71e05f06742e44b1b5ba2619e3d45e6e77e56ddca00221765d89baf7a0cb1cf9427d5cf0181bff6cd217684ca7d37c6a72cb6d0964aeb2b68c3730a3222fbcec11ece326a1dfa139cf5f3f0ff66543de09cb8d83958fe22730b4c3f409aa0ba82793d2a3cffc35555c21ca97cca872c9ce53c0ada2e8a42fe89ca48330e214c90f4edabaf468fb3b0567cc5c5d47e09df10a4fc87ee7e1bbbf2cd10489b84b6c5f9608cbf18201e049795ac3df14ec026ff8304c2db6dc76bb1130219c69fc7f1ca5dc99df631520b4d7ae67181bae4ca34bf3a8c132a40da221b2e4dac2afa6d1326b6d020b6947b5af5541b79f3c6b7da64a3d2f64e1afcbe1da6737d1722e2a056c015f459f6bbe7280f2b278634293cc7fdc89401fca8a5cbb9289c74f71d3ca525a3b2da1fe6ae75c351274ce1f66b8eb66fefd63de86bf064b593a6710db839e4d3853dc135a04de1e54267841de7ac150106ca59b6a94607dfe1101fc789996b4fa06e74a5c1f4ec9e53140b86c897b68322004a7a9a25957cfb12a841c141603d9e8d37044ecb2bd093b6df530bad2e875a2f1f16630a6f482dcc312e5f0287fa7e7a503721bdf6b75d959a605c7b19375fe7c1b3248a1f4d55f6e87c1e601598cfa5824e625175c6ab35642f49d37cbe19c7d834021e4266562724f616cd1db2597f5204ec70eccdc681f2e803c75c5e8a2ac7f908e0a9f84d72a9cad88e3eda7170bc4af77293b426bab66bd8e05cef88c264baae9ddc54d4140cefb33bc94b788f2a88eabe136cba74c7f49cf1daa909a56c8ae8ff1385a947684d8b4709ab66b147aa417d4c76badfc4b8385447d2e2be750557d0ecdbca5d860055ebfa2ba7c0a3e8c7d07eb0bf6b6fa88bf8aa46ed98300bfd5309c9028369b1bfcb180284a4c8a950b7580c78a3da3cbf02c3ce258945c9173658348a0a3c0c69eacb763395d687b788cd998e8c582014c20b2dd6d40e49dee6d4b0309bc5a30f872be7e5c35a659970a6d57c9cb710d32fe70903340bec79106beff811d9fe68136d14dc7112191e6aac9ab8e89dd4dcc96bc88a65fd63168a87f79d93d3d027633ae5306c15dd05c639dca4d024e66e97fbb3dbde05b51530200f465e7df66c13100eefa1c31400cdae01d5491a17e672dfc8ad46dbc0af5bb92328f023893153fa743ca7328d4350d6cf39071c68c6c555d84a601bae80fb32473f9e3b88f7b8189012ce6a8f228b478533ca8b0e59c35766b6abae322259e18910aeb320b2997b194597aad6b0b82f910dc42070082b62238cf6487351d1c80caa843547c4446b1078e7770a486cf8a408d81b31fd0791a983dd91fcfde44cf24c38af6db8dcbcb757af1058e863dd33413012a1767ba45a48a8dc36fa8e0c44bb6aeffe5aa62583a121680e7d2fa114ae43c80cf9289016af7804e4df9c7543a5babcde5bd2eb47c291cd9248b14c69c84f929316c1256cf1b0649be81414693170b366fd50a793a6259973c10e63c249d6361d5cb3b3a14262dabbfa82d7b2c7627229316b9eeaaa86424b5fd05174ec43c6c071332a4ab0f4761fc025ffe168973261eb0f2928f342c8b5d7ba7c2b4d9b95e4ac7e8efa08fc218dfffeea7b344775cc35ddd45b1990c873e060745dbb660a10ef1e8f03f1ca8244526514b7bd49f2d8e226f8cb221eb3783af9043bfd9d666a513c3c900e18e1629938192b4b9c91e7f98d946987e81cbef6850c92e8d490a3e22079c22ffb2ccbecd6608048a5b25fdbc8b015c1b42842dcbdd7f9a9fe183f14346b00c03334db7851abdf9e26d10d59a33251a4315f613ba192ebc8d49eb9f96a890d8afd8a1ac4257df55ae32f9f55dabb55f2ea9fa21fb48de461898182719a190d29d22756916a14ad7f357812fb5681dfeaf10ad979ec21dc0fb66de37b386d5a892834a91f7e72ab4f07aa1eb8094ef1228e04537fa6636336f45f050d7119951fc0dfe444fc10b9a796b29cd3c65e79c648426e3d5fe6c28f214e97e011830cf50ff090112765a5e2404ef28b100bb114152df1f6e115465f1f3ad1f3acc74e2c8a646cb6145258e0648ae09a1f8e6468dfbcebb3437fd1dcfafc4c088ec11831d50e21a2e36a464a8b8ded52e80fac90f05bec019538cd5fc6384d4cbc799366adb2637b202f32c7edd28a9ba26348ca789d8dfa1bdcb4db3e7c05aebe83f35725e13189b611f133b0f8d6586c53809d6976a2dd5299a5b0436a82484a30743616d4c6556a14df8ca95a9eabdad6497bdc80703890a2e4ee1f54847a741c84a899f27a99d20901d88e1c1c746b425547647bcba8ed6b032d885a929cf1b3320bbf6023f75c5e8bfb4689deff4e78e2f30f1c5c4875706cc72d50cce726e33f0902c2e133e31fa529e0a582fe33ebaadb164c0d97b2aa568bf21ac7123904b1e7bea44ef9dded4fc02376d117032929333cb282ed5e124948da06a4aa38c237d923f71cbf52284a2f5661e657bfb5e88114073839e7d8b41ab2dc872dceae98770bde61b694b8542110f5866216661f321048c653dd021a7d631ff737ac1cc72352204b6911032c5ffbc9f5683955919a441fc67a740260158d6bccca9c2a8014f6ace55009e7c82f4ece20d1e0d42bacb9197a80810d3f6ce527b082b2df0dacd98d347481ed02bce8cb5a0bf23ddc1df38459db0692c452787e3db115e59d0e01dba1e8994aa66d7478e6933d6dd97a2fd5e7e8053ccd885fe45d5893b4e97df16099b0cc96ea15ad241b661a175426532b6be43a10f27f60c575f5f0beb8701044d8765b9a56901d48580741626e6ebef68e999795306aaa52109d8fbffdb5752476d4c5bb959e374d945ef6edde7921850a0b7877cd6f104950f12fce889ac4cdb1b92eb14d8ac496930996f16eead8fd7e4eb246e76d2f8207d89213cb7c4cd023c6abfe4c74a634b5f7c9623d236d45d009389b936762b85a1935b4336ffb46935f78bcf250d2c5529f933451aeef8bc4a058a14589577174ff503db7a35f07ed04f62d1303dad05586b061745cad707987887e58beea0a810f32dce392e794729e1fcbef55afa5e6f58d30f25992842206b30ef4e9f20eef152988922c7a8cfb4b6181216f631c405c693486cc66a3b1346b8bc465b25f5320442adfc9514b0ae4ae27b2fe8a85a351e6788316910225ac3dda18720b0164ad75f3865c7908114e3d0052bf4586518b6664ca982217a91892e7565caeff2d66f454f9a477bfb136ef6b8ca89fdf5a26b17f5cdbd3845468cc2bb0d9a7ad56ac467791befc90e347c0425d15368bca3cf6eaad9761afc31d61bd1830ad47b59f3392c648125c0f9a821d3f68f823d1c956ed13969a92972a06f0ebed76ace71576a2578d81e54dc54e4d37f402b42865abf63479255a715c7099412586e95c28f0ba6e2c5cef142558044bdb1bba23be47a56ca07c3d47bbd16cf9a1708edcb20b7380b813ae28e43a968f7a219a3c4e8e759e77fe3582fafea935a385a55d23d6989e56d9a04d7a6b73005c7e1d68e2e0dfea9d6567ab23c3510d6a52ae2768770cded1b7ea4dc5eded44a6f3b17961b1b707135fa19c0948b33fb858f44ea5a10896c6c9ea042752556c05d4497a7da44b581925fc94e295ff33876a7b970330303c7c120a1b7e7ded4f59c7583f49ff651b92d24cf9bc1d04a5a112585b14155a2f7526e111cb5ecf29aeed735497aa486c1a479f61b6fe3cb46425c1e04ab2cd8b7ff7dccacc82b277af5df0c95908da24c66a2a663fc8e38c24c5ed9842043600a4afecc7a390c72f262b070c3764068d0461ac2e4503376192e0dc620b5bc607a10af8a59c12de392fd5cbfee3e45f0f4da64de97f0754e7dd09979d8369aa384a1b4bcf7c5e96565f2e6ad37729dec8e22d35aff7d09f7df313c0fbaa09f02916f4de929f44d29172faf939c817c1ea58c0bc7f10d052b085e4dfc7e2dd82b53289ed52d4c2b44a3ee243e6acc0b4caf3fdca51f6f7d23780d1279a7d8e145eb9a37896acd8ee1375ce4c69bb06a8d4cb0496702f2b583c60657350448b83ddf1d3f0026e8347d2a972bdbe51bec5d33f958c69b9b5697ab91c3dab0fb164ce77ef9cff510cf677935275c06ad671ef9099658c620f381b3a37cfb6666b0d3ef2d9ccb834a5fb21894b4460687dc55aa0e95dfb3fb1c6d4967be7dc6808260441d37d05feee3339148306444d60677d7296c029bd58a98d11b489aa58cb9e1a61b244cb423e570b16fb83c8f62daf27cd39ac1f74dbc8764252bc8f4d0f52ba7126ff94696381ce924506cfb6913c46280210ebfa21698bf14df0e8d2885f70fc5777ede938c2363a738d4c6348808c15164e2e0a1a1d5f856cfb158095ed7b1dc8af11530ecbdd863a7850e4f2acc9e870cbfb07f02fcbfa7a845b2c4729fc77639057375dbb367d594b053e80901b70f2b69194a9cdc4a8c3f3eacf04d264f4bd070d74f8827bb6e3fb914c5ac32946241ef6760042a4e46d0b22e1fe981c4bc05f32bb492c3f4dc68cb2de55172f8873e1121e9442c3002373dfd8c39f855114d16f22cf9c2b185e7131c13316ca90479b5def23158f53b532e73380eca73a7fb737ede798f47ddd5e35387912c20d205611448c7390b4130f57b190851b570750450e3bf88a47452c74c94fd6a7898dcb8c42ecfcd2b24023f8615a374a1e791116622aea9a0f192007951bb4a023dd4978976758a19cb3724f1c53f3da3e2839287709584dc6cdb856774558c6b63c0684c306cf9511b04ad532ca540932d744d30e3736cd592db655a263dbfbd7a2210ac807193ac3a8643bb3880cca4dfe2c7ac874f3b71b0f693e991899c4158b3ba041482c72699bf153987c3cd2b8cdae8c0b4585737864b1f2eea1db73a001fcc9d412e6c9d762ebd95eff5cc55e400f8c495c440770746ed5871aaeb85130711d375d02db74cc4035e5544a4c4fe2cf621d961b99c51bd32cf1df32818d961ceeb5e6853e44300713c46469402c28e53473494f5d3614b46bdf1037f8d5d3586bdbd304aebe6cc436d3b53c16c8e776d4a362d15cb0c485742a5b2e6bd25d1913e5d4a39dbccf90d9e3ace56f9b606562fa6b79cdf1a3d30993933017c703ce7d81a1098f7605f3500a88d7385431cb8004f723262230aef8c014f60b45dd51fd124b889015af61aacebde91258941bd73651405271206dc930c7bdb72bc70c74ed1513100ae45f892259a819b62ee1d449795d1779d8984961a8670d4a73ef4da065dba8810e57caae50f539cbb187e35af0dfec1c69ddeefbaec0d1ae669898b4a29603e51a33d7f763002d030976c36e1ad371d27ca1904ae93ebaf36e5e6905f22cf27c2b9bc77030d6ce3e70878b9ba11c8379591b1fbeddc58ae26a0d8db2ed60a6b58416874619c51e4e12a42e4d30e1503c1ebab7a24adf3aadbfb1b392ac0e14eb6e504807023dcfb07501a8fdc14596e65294b6ca82609e6518733557b077d4ec839bc5f0a38f777ef4e8cf629ada6b1ffc7517d023758768acdbfdc08f5fc30792e5ad9b742fb4d080e5f9ce79380508213a29987fa4ed0ef30783c25aa3b18ec03d2237c76eb456ebaab9e82942525145265e309f5e622ca79628f1baf6306636e683d25ff154d36d3f9b159b4429d2200885ee46dcfa926d10e5f07b4e4038da84e9bb94ceb2502fab2f0a4de05fe9d35ae15eb19a6e0126f904457527c30300f7f52a70175e6de115843eada40274b4c04d5da930818e7f060f9d9f4aca7bf7c0c2b8833635beba733e0f85af1e3d2ba6e68cc361db0901912d3883e07ab0b2c25f1c7ebcae881ae0a9a37eb3fac0d5c673f47e1ce3ed20e4f68b5ff5786ff1666a62f5fc61c558e290348375382529e9e3f1144716104c0c8096ad3c4f6b7b04f8208b624522262c111e20fe17c3fe5d3399d0c5a6709df66430e7abd6b6ca177a109cf845677720b47d0d8406ed758b9e01b15bbbe9213d4e4542aa8be373d7d4c64f44d534bae44660b8ee510e631a8a973c843e5b1474eb5c1a80044aca8377061c52406ccc01e785794250b7fb0357e17312b3504deba8ff2bbbb5200ebf43bf13f3c6b0e38b2a4b850ddcc48803f8a278dcfbc59f1253492df144316878ce4eb74ec3395de8989bf39382a12b4d9f85005cd23018fc48a64f19f6d73c0fa0043f43cd65a6c93c6b9f9b8f5e76138d68d0bca53c798f46a633b5d790d35ffbb218f173b1264f563c2c348ae9137cfb3d0dd802c46871ab38b87ec841d696243e6405e5144f39ec97168f0209105424e1eecccf8c65f16da333398987d7a98939048313d42936960b18f0087f18f1655bc48c56c50b418bc29a7ab3520ae8e2bc6dcf5492fa92111c50e0fef83c101a8994f2a23b89c1adb76048d94f56ec08f9aae92095ba93fc05eae93eaa8a5de075574f88a27f025542741748171f8684138a2ef918194b232ffd5b829830284662fe71b27b01f5f098b2ed0034cf132459611e064d0436a488b619052979d186e6bdac1cbc82cde2d1917182186412c2ce435d17334b1194e2a75d6c32f335caf7295ca51ebc4e544f21868ba4f516cb63891d4821afd04666436c07fa38b0ba2bc99ae11c89d908fe27bfd0edb39c0acf76c7f75f00fb83c5e36c9927e31a5828149f55fd52338736c2b33495d0cce18ea9202b3af6a25dad01acdd445ef67a5d6781260d718ef9890a72195d80fd29ba0046be0d8822b70e6d9da8c375b648ec8974ef48cf1cc43a9345daecf5643885a699a8c1b3823d75b5b10173af7641efb2002abee10ffae71344b57c517568bbe088a9a2dc8ff72d6471261f54f8bd12e6eb1268bb51fcdcff84da0536643540fd17ea16d623be9b5e458aeb23a72279671a6c3e01571e71a1043c4ac0868e5e418450607bb3475d32ed3ea58e6d2cc130c4ec00f6f6cf3f53d710af2d6e397c2d9d09e8d937b9c65b45daf9ebb357bec1903058569a88049432411f621af71ff0667840389a65d5e744b27d4be264863f36ed8d31d919188eaf3e51789e11220bbb4f2bee4222f248b277749bf8317f67545321288895781ce8d0efaf76fa1dfddd2d29f7de265c96857e145219a6bedbd12be9859aec86e3303b2aca4551b7aa338d0e5cf451daf2ce04f29103684609ab6a0cf3b2316e204a32a35e45cfb8cb52c85dde2d8503bbcdea4725843be578404b2342f4cb95f81e2a8d899dfb1cb598f6a3ee9b79aa9e61b7d46a2a1d7b4f51c64fd85cafe1d1800728d80c02527594dfe44911b2ea08ffcf54b903a2e9919ae950f0eeb202c045e8822b45aef030a41a5c103caafe123a1bed2826dc79bcefccc3c092c834c64b420a381d43ccbe8a75987c6156c15359788f0ba9938851ddd0c55ba3372a11568ac8f3476dbff6184c70e45ce70077a82d2bb0bcbaa16086126b636f8e814a46e9e936e4afbdd75b3778440e12f388c408709d6be380f66c2efc943cedec43f5111a9a5b1f717e1e41afcdacea9c0af33a4d24cf06648088f38be8accc22e16d33c5ce76c3f9fc5b8555d79b6fb0fa37e1ce8a59d07f7363445e4d2ba7c5735426d83b5730df52ac4b398d4b900291e9689d534aa3e916fbb0abbe9ea65de5ca572aabed556d4e3f47b6e0d48c4a6a501194fd076ffb908d53751cbcf797ee10c26abe7e59a2f3de41fa5d44c34a0ae901da6a0294c5ac9b6b1df54b2298549a29f39c2ed64686406b010bd9598b1aba349c4efe204027daf61b95fd70dcfca4443a0a27ad1fdc72e673cb460d8a0dc7a5fedc7849d21e0b5f30ceb63bd8125b8924567de450f0273c83d69578b79e181383dad350d80c587ea5fdfcf56d8e9f2fad26c4004f7adc915d32022151857aecce8ce7d38aefd2d39311b55f471898c4cfacab07515a44d6652faea949012c1710ed86d623ed0809af2fad3dce2120efc0da958bc09b64e723afad4e7869f7fba53ee00bfef64a0bed5faa1f9816355d1103ae722918d430e96da81b583ad9754b787366d5d6cb3a50eb57a86e3131f92f47b242354b18477542f58d7b368bdeeefc8aeb22adc145454655e79806343806c368fc0dde3e8783fba5ce982d06670ca84cf263417a289d5a08b92ef5b0c6e132fdb3f42c78cd43f5c6af1a99a9d9785fc8623c90f64ae857567738936d305bf7578e5dbbd4ed02fed68d3ec6f926405b89dab9146271177258057347d806e6b06e21549938e7773b219dbabceedaf080bebf96c1d8d527d54852227b72fa3b203d895251d0af3be3f8ab119c48935a45fbae50ebfd6230864788df918b2dbbf23f1dee89580f8ecb734b6a21c2562a17d4a952f9518bac631b44eb1dbf454c418508f330b20abf2005c12d74f0d34c350a968ec434c9fcf8761235d9da0c41cdfc2adb8d79f829d46f5b65b18bfa55729c34d151bcac8b54c0a474fd2678a3d2ca998e108d134fc9ca59dadf095d24017ee944dc08c61dd863cc907478fee8e643a44f51026b45d9f0d02a4fff3dab0d2b2c0b7f4d8f2c96fd103601e46da464a4257a3fae0b7fb4c5cd7a32a2dfce340c903385387c31235695e712d33251f614915cd0a7c25c56a4ef08a86bb810c0e81c727816ab4bd25886e17dd41db1a9ef49dc1727cfbe4ec1453b863894225a9ed58ea3af1cc8b86fcd663930bfdc41a77ce2b5d963ba9e5529657aa9dc245d4138414082a2dc9aeebcfd8ac52371c8d62127c8752f71fa04ba30dbc32209e64a6dd5cb36e22b9b86541ac9b99c8d22f0c7ce004e446a2a611a4ba3e112dd0947c3eff20bce025b8a0786ed5afb0bb8337ad25d60dbea3152b0cc09d12cdbf64c36d61271c0c21639c2267fa2805220b108d28083e75b025155bc674a4f5674dd5623951dfe566892c36a6f70c174656151033b20c8f86b5dc946ff9ebc71bc2e38d71bd7269ad3e1056ce124ca2594045521f8a9c345e783243ca311ebd645741e9b958c3a7ae97d385ccb7f14e153af0033061b7ce36917374f85c36f78d2d62f92e36d707cdd761cb3ee87aecefa43a58f67d0aaa93f3ae58200ba40b0c25a9ec2f54c14572b2a7fb0ebca4f4fbc0aab49dfa6b47411d4e7e5c5d96a5c242fb94d7abb93c34fe30ad64f286034a8ea94485364da3a0e7ee7688101603d5a405c25422d5b434b9cf1416aca139a576ddeba463049eb1093ca94fcc6b4b07c0473b5f569029456925c9d2dec58f42137a8faeebec28a3cca58c3f384deb6cfc64dc5b35ce16e5836da11dfc834eae2bca938680ecc3adb9378f212b025a57d99a293bd7b272fa69c7bbc5ac0c062b280d5fefb744b40f02053321f40669cb5159afc1f14940a5937ebe48f8987f666ab2a8c73fe1c83bc3ed70deb966d7aea1466e4f7c203aca48fc06ad5dc9ade322475de134c23f786e4088efd157131982daaa84d4fb8d3c84f579caf72d1275cac4a4626a9074a070bbd5cab6ec99f9001384333b35fd8b0a8f0de0205f280e03090e3157d5764586a90335b0e3d25bbf9de5fad68a10329d40bb00024d3a7c4186336ec68952bc427c3c8b44e13a5b5511b4dbb0ee2fdcbdffb906a91d61b2f62a5d9b7542fa5d3fc5caf185ebb04199f94b6c7f78555c11f1f116b3882d4f45b29853f43042b9deea29dd3acc017ae7b6ae228d4dcdd20a158f6b126df102d03e81cc07debd938e60ccfda9c2f35261cb8a05c6bf2fa00ebdb31a1228104d1e602c2c64553a4e30b58fc873989e720a78ce6f500e4a1306ed2f50135f568df708954a2d624d5eb5f13cfce2ab28573a477b26f146e8fc8847dffb91a8726bb9e1fc246772b197eee95e1110fe4c5c92316d194a6832a7d8fe429ec604c9cfe7e03d3722e9b0a209bfde9a7f10b40027b720e506b3a11e423acb6f901075544eec41e36aee4a9cdd599beae0a1d6414059141c89ea6aaa4b7b2c0e943c706eb8087204e2b9d7f706613abcbf8b12ec46bbcd05ded2f2ab620cb4ce46bc4207147c8879305546b50dc73caa89a6a6953ed54b833bef3235bc5215cde9cdd98c02b13a871fd543bf5fac90e37ec4bf5f725f1dc5e88141bcb63a9bb00c5e97bef34e6040febd082c2658ed662a0560c134fecde4f4f8d51a29d5ba77c7d91e81cb82da114fa7b90265c092453eb5d1cb9592c1807e7be5c4c514e47e8c73c6f2d23ddb8d4cb4101c6684de00d028c817d4b4bc2c4534c1bb0ed1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5e19b8da94354cffec50e3192733402c"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
